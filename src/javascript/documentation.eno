# Global

version: 0.7.0

-- intro
Installation from npm:

```shell
npm install enojs
```

## Getting started

Create an eno document, for instance `intro.eno`:

```eno
Greeting: Hello World!
```

A minimal example to read this file with `enojs`:

```js
const eno = require('enojs');
const fs = require('fs');

const input = fs.readFileSync('intro.eno');

const document = eno.parse(input);

console.log( document.field('Greeting') );  // prints 'Hello World!'
```

## Interactive code demos

An early preview of the enojs demo page, featuring interactive code examples, is now online at:
<https://eno-lang.org/demo/>

## Links

Package on npm - <https://npmjs.com/package/enojs>  
Repository on github - <https://github.com/eno-lang/enojs/> 
-- intro

# Modules

## eno

-- class description
The main module. You'll be calling `parse` on this, and possibly supplying a custom
locale (such as `'de'`, `'es'`, ...), reporter type (`'text'`, `'html'`, `'terminal'` are available)
or source label (usually to have filename appear in error messages) to that call.
-- class description

### parse

syntax:
| parse(input) → EnoSection
| parse(input, options) → EnoSection

-- description
Parse a string in eno notation.
-- description

-- eno
color: blue
-- eno

-- js
eno.parse(input);  // returns [object EnoSection document elements=1]

eno.parse(input, { locale: 'es' });  // Any errors will be reported in spanish
eno.parse(input, { reporter: 'html' });  // Errors will be html for e.g. web integration
eno.parse(input, { reporter: 'terminal' });  // Errors will be colored for terminal output
eno.parse(input, { sourceLabel: 'my-file.eno' });  // Errors will include the label as context
-- js

#### parameters

input: A string containing text in eno notation.
options: An options object.

#### return value

description: An `EnoSection` representing the document.

## EnoSection

-- class description
Every section in an eno document, such as for instance `# notes` or `### Appendix`, maps to an `EnoSection`.
More prominently though **the document itself is represented as an `EnoSection`**,
consequently this is the interface you'll be utilizing most for many usecases.
-- class description

### assertAllTouched

syntax:
| assertAllTouched()
| assertAllTouched(options)
| assertAllTouched(message or messageFunction)
| assertAllTouched(message or messageFunction, options)

-- description
Assert that all elements of this section (and also, recursively, all
subsections) that were present in the parsed eno document were also queried (and
therefore *touched*) by the application. This, combined with eno's query
methods, serves to ensure a two-way guarantee for both users and developers: No
data that the application requires can be left out, and no data that the
application does not process can be supplied.
-- description

-- eno
Important data A: I need to be processed!
Important data B: Me too!
-- eno

-- js
const document = eno.parse(input);

const dataA = document.field('Important data A');

// ... processing happens only for dataA

document.assertAllTouched(); // throws an error
-- js

#### parameters

-- message or messageFunction
Optional, usually the default message (*An excess element named [NAME] was
found, is it possibly a typo?*) will do fine. If you want to override it,
provide either a static message as a string, or alternatively a function
returning a string. (The function is passed `name` and `value` inside a single
object parameter, although `value` can be `undefined` if the untouched element
is a dictionary or section)
-- message or messageFunction

-- options
An optional object.
 
`only` - An array of strings, e.g. `['name', 'email']`, which tells enojs to only check these elements for whether they've been touched.  
`except` - An array of strings, e.g. `['phone number']`, which tells enojs to exclude these elements from checking whether they've been touched.  
-- options

### dictionaries

syntax: dictionaries(name) → array

-- description
Retrieve dictionaries with the specified name from this current section.
-- description

-- eno
image:
src = red-roses.jpg

image:
src = white-roses.jpg
-- eno

-- js
const document = eno.parse(input);

const images = document.dictionaries('image');

images.forEach(image => {
  console.log( image.entry('src') );
});
-- js

#### return value

description: An array of `EnoDictionary`s.

### dictionary

syntax:
| dictionary(name) → EnoDictionary or null
| dictionary(name, options) → EnoDictionary or null

-- description
Retrieve a dictionary from the section, optionally supplying an options object.
-- description

-- eno
color ratings:
red = 5
green = 7
blue = 3
-- eno

-- js
section.dictionary('color ratings');   // returns [object EnoDictionary name="color ratings" entries=3]
section.dictionary('temperature ratings');   // throws an error

section.dictionary('temperature ratings', { required: false });   // returns null
section.dictionary('temperature ratings', { enforcePresence: true });   // throws an error
-- js

#### parameters

name: A string representing the name of the field to return.

-- options
An optional object of options.
 
`required` - A boolean stating whether the dictionary must exist. (defaults to `true`)  
`enforcePresence` - A boolean stating whether the dictionary must exist. (defaults to `false`)

Note: The two options are obviously redundant, here's why: `enforcePresence` affects all elements,
therefore we need it here as well. `required` was added because it exists on other elements as
well (where it does something different, namely, enforce the *value*) and it would be odd if
it were missing here now suddenly, so that's why there are two options with the same effect.
-- options

#### return value

description: An `EnoDictionary`, or `null`.

### enforcePresence

syntax:
| enforcePresence()
| enforcePresence(enforce)

-- description
Set the default for all following queries on this section of whether the
presence of elements in the eno input text should be enforced (by default it is
not). This can be used to prevent "template decay" - with presence enforcement
enabled elements may be empty, but they (at least their declaration) must be
there in the eno text and consequently they can not disappear from a template
over time without triggering an error.
-- description

-- eno
color: blue
-- eno

-- js
const document = eno.parse(input);

document.field('sound');  // returns null

document.enforcePresence(true);

document.field('sound');  // throws an error
document.field('sound', { enforcePresence: false });  // returns null
-- js

#### parameters

enforce: An optional boolean indicating whether to enforce or not. (otherwise `true` is assumed)

### field

syntax:
| field(name) → value or null
| field(name, loader) → value or null
| field(name, options) → object/value or null
| field(name, loader, options) → object/value or null

-- description
Retrieve a field's value from the section, optionally supplying a loader to
validate and/or transform the value, and/or an options object.
-- description

-- eno
color: blue
sound:
-- eno

-- js
section.field('color');   // returns 'blue'
section.field('sound');   // returns null

section.field('sound', { required: true });   // throws an error
section.field('sound', { enforcePresence: true });   // returns null
section.field('texture', { enforcePresence: true });   // throws an error

section.field('color', ({ value }) => value.toUpperCase());   // returns 'BLUE'

section.field('color', ({ value }) => {   // throws an error
  if(value !== 'green') {
    throw 'Only green is allowed!';
  }
  return value;
});

section.field('color', { withTrace: true });   // returns { trace: [object EnoValue name="blue" value="blue"], value: 'blue' }
-- js

#### parameters

name: A string representing the name of the field to return.
loader: A function returning the transformed/validated value or throwing an error.
options: An optional object of options.

#### return value

description: The value of the field, or `null` if empty.

### fields

syntax: fields(name) → array

-- description
Retrieve fields with the specified name from this current section.
-- description

-- eno
color: blue
color: red
color: orange
-- eno

-- js
const document = eno.parse(input);

const colors = document.fields('color');

colors.forEach(color => {
  console.log( color.value() );
});
-- js

#### return value

description: An array of `EnoValue`s.

### list

syntax:
| list() → array
| list(loader) → array
| list(options) → array
| list(loader, options) → array

-- description
Retrieve the items of a list, optionally supplying a loader and options.
-- description

-- eno
colors:
- pink
- peach
-

textures:
-- eno

-- js
const document = eno.parse(input);

document.list('colors');  // returns ['pink', 'peach']
document.list('textures');  // returns []
document.list('sounds');  // returns []

document.list('colors', { inludeEmpty: true });  // returns ['pink', 'peach', null]
document.list('textures', { enforcePresence: true });   // returns []
document.list('sounds', { enforcePresence: true });   // throws an error

document.list('colors', ({ value }) => value.toUpperCase());   // returns ['PINK', 'PEACH']

document.list('colors', ({ value }) => {   // throws an error
  if(value === 'peach') {
    throw 'Peach may not be on the list!';
  }
  return `I like ${value}`;
});

document.list('colors', { withTrace: true });   // returns [{ trace: [object EnoValue value="pink"], value: 'pink' },
                                                //          { trace: [object EnoValue value="pink"], value: 'peach' }]
-- js

#### parameters

name: The name of the list to return as a string.

loader:
| A `function` returning the transformed/validated value or throwing an error.
| (The function is applied to each list item on its own, being passed a single
| object parameter with the keys `name` and `value`)

-- options
An optional object of options.

`enforcePresence`: Whether the list must be present in the document (defaults to `false`)  
`includeEmpty`: Whether to include list items with a value of `null` - represented by `-  ` in the document (defaults to `false`)  
`exactCount`: Validate that there are exactly `n` items in the list (takes a number, defaults to `null`)  
`minCount`: Validate that there are at least `n` items in the list (takes a number, defaults to `null`)  
`maxCount`: Validate that there are at most `n` items in the list (takes a number, defaults to `null`)  
`withTrace`: Whether to return a list of objects with both the element and the value (defaults to `false`)
-- options

#### return value

description: The (optionally transformed/validated) items of this list as an array.

### lists

syntax: lists(name) → array

-- description
Retrieve lists with the specified name from this current section.
-- description

-- eno
route:
- vienna
- paris
- rome

route:
- moscow
- riga
-- eno

-- js
const document = eno.parse(input);

const routes = document.lists('route');

routes.forEach(route => {
  console.log( route.items() );
});
-- js

#### return value

description: An array of `EnoList`s.

### lookup

syntax:
| lookup(index) → object or null
| lookup(line, column) → object or null

-- description
Ask the document *Hey what's at column X in line Y in my eno file?*. The lookup **always** returns an element for valid indices
(the document/section in case of an empty line/space), only indices outside the range of the document return `null`.
-- description

-- eno
color: blue

# notes
-- eno

-- js
const document = eno.parse(input);

document.lookup(3);  // (= 'o') returns { element: [object EnoValue name="color" value="blue"], zone: 'name' }
document.lookup(7);  // (= 'b') returns { element: [object EnoValue name="color" value="blue"], zone: 'value' }

document.lookup(1, 3);  // (= 'o') returns { element: [object EnoValue name="color" value="blue"], zone: 'name' }
document.lookup(1, 7);  // (= 'b') returns { element: [object EnoValue name="color" value="blue"], zone: 'value' }

document.lookup(13);  // (= '#') returns { element: [object EnoSection name="notes" elements=0], zone: 'sectionOperator' }
document.lookup(19);  // (= 's') returns { element: [object EnoSection name="notes" elements=0], zone: 'name' }

document.lookup(3, 0);  // (= '#') returns { element: [object EnoSection name="notes" elements=0], zone: 'sectionOperator' }
document.lookup(3, 6);  // (= 's') returns { element: [object EnoSection name="notes" elements=0], zone: 'name' }
-- js

#### return value

-- description
For all valid indices within the document returns an object with two properties:  

`element`: An `EnoSection`, `EnoDictionary`, `EnoValue`.. . For empty lines you get the containing section.

`zone`: A string denoting the token at the index, here's the full list:  

`'[empty-lines-and-spaces-between-tokens]'` => `element`  
`'[inside-blocks]'` => `content`  
`'[inside-comments]'` => `comment`  
`'[name]'` => `name`  
`'[template]'` => `value`  
`'[value]'` => `value`  
`':'` => `nameOperator`  
`'-'` => `itemOperator`  
`'='` => `entryOperator`  
`'--'` => `blockOperator`  
`'>'` => `commentOperator`  
``'`'`` => `escapeBeginOperator`  
``'`'`` => `escapeEndOperator`  
`'|'` => `appendWithNewlineOperator`  
`'\'` => `appendWithSpaceOperator`  
`'#'` => `sectionOperator`  
`'<'` => `copyOperator`  
`'<<'` => `deepCopyOperator`  

When an index outside the document is supplied, `null` is returned.
-- description

### raw

syntax: raw() → array

-- description
Retrieve a native javascript object representation of the section.
-- description

-- eno
color: blue
-- eno

-- js
const document = eno.parse(input);

document.raw();  // returns [{ color: 'blue' }]
-- js

#### return value

description: An array of elements (also returned in their raw representation).

### section

syntax: 
| section(name) → EnoSection or null
| section(name, options) → EnoSection or null

-- description
Retrieve the subsection with the specified name from this current section.
-- description

-- eno
# content
title: A Manifest

# notes
-- eno

-- js
const document = eno.parse(input);

document.section('content');  // returns [object EnoSection name="content" elements=1]
document.section('notes');  // returns [object EnoSection name="notes" elements=0]
document.section('metadata');  // throws an error

document.section('metadata', { required: false });  // returns null
document.section('notes', { enforcePresence: true });  // returns [object EnoSection name="notes" elements=0]
document.section('metadata', { enforcePresence: true });  // throws an error
-- js

#### parameters

-- options
An optional object of options:  
`enforcePresence`: Whether the section must be present in the document (defaults to `false`)  
`required`: Whether there must be a section of that name in the document (defaults to `true`)  

Note: The two options are obviously redundant, here's why: `enforcePresence` affects all elements,
therefore we need it here as well. `required` was added because it exists on other elements as
well (where it does something different, namely, enforce the *value*) and it would be odd if
it were missing here now suddenly, so that's why there are two options with the same purpose.
-- options

#### return value

description: An `EnoSection`, or `null`.

### sections

syntax: sections(name) → array

-- description
Retrieve subsections with the specified name from this current section.
-- description

-- eno
# Article
> ...

# Article
> ...
-- eno

-- js
const document = eno.parse(input);

const sections = document.sections('Article');

sections.forEach(section => {
  // do something with each Article
});
-- js

#### return value

description: An array of `EnoSection`s.

### sequential

syntax: sequential() → array

-- description
Retrieve the elements of this section in sequential order. This seamlessly lets you switch from
associative readout to sequential readout, allowing sections within, or the whole document, to
represent document-like structures (think generic markup) instead of just associative data stores.
-- description

-- eno
date: 2018-03-01
title: 'My blog post'

# page

h1: Hello world
p: This is my first post, I'm so happy!
-- eno

-- js
const document = eno.parse(input);

const metadata = {
  date: document.field('date', myDateLoader),
  title: document.field('title')
};

let html = '';

document.section('page').sequential().forEach(element => {
  html += `<${element.name}>${element.value()}&lt;/${element.name}>`
});

// ...
-- js

#### return value

description: An array containing the elements of this section.

### toString

syntax: toString() → string

-- description
Retrieve an abstract debug representation of the section.
-- description

-- eno
color: blue

# notes

buy milk: important!
-- eno

-- js
const document = eno.parse(input);

document.toString();  // returns '[object EnoSection document elements="2"]'
document.section('notes').toString();  // returns '[object EnoSection name="notes" elements="1"]'
-- js

#### return value

description: An abstract debug representation of the section.

## EnoValue

-- class description
All values in an eno document, such as the value of a field like `name: value`, the lines inside a block,
the value of a list item, the value of a dictionary entry, and so on, map to an `EnoValue`. Usually you
don't interact with this because you directly get the values from a section or dictionary in most cases.
Only when you sequentially iterate a section (with `EnoSection`'s '`sequential` method) or explicitly ask
for the `EnoValue` by using an accessor with the `{ withTrace: true }` option (for delayed error triggering)
you will get to interact with this class.
-- class description

### getError

syntax:
| getError() → EnoValidationError
| getError(message or messageFunction) → EnoValidationError

-- description
Generate an error in the context of the element. The error includes a generic
message by default, or a custom one if you supply it (which is the recommended
practice). You can also pass a message function which (like the loader functions
too) gets the name and value as arguments and returns a message string. This
serves to create highly informative error messages that pin-point to the exact
origin of the error, even when the initial reading of data is already past, e.g.
when the error condition is only apparent later, when more processing has
occurred or other data is available.
-- description

-- eno
color: cozy
-- eno

-- js
const document = eno.parse(input);
const { trace, value } = document.field('color', { withTrace: true });

// ...

if(value === 'cozy') {
  throw trace.getError('Postprocessing determined that "cozy" is not a color after all.');
}
-- js

#### parameters

message or messageFunction:
| Highly recommended to provide one (but it's optional).
|
| Either directly pass a string, or alternatively a function returning a string.  
| (The function is passed `name` and `value` inside a single object parameter.)

#### return value

description:
| An `EnoValidationError` in the context of the element's value
| (and with an optional custom message).

### isEmpty

syntax: isEmpty() → boolean

-- description
Query whether the value is empty (e.g. `comment:  ` in an eno document), which in javascript terms is equivalent of `null`.
-- description

#### return value

description: `true` if empty, otherwise `false`.

### raw

syntax: raw() → object or value

-- description
Retrieve a native javascript object representation of the value.
The raw representation differs depending on whether there is a name (e.g. for a field value),
or not (applies only to list item values).
-- description

-- eno
color: blue
numbers:
- 13
- 42
-- eno

-- js
const document = eno.parse(input);

document.sequential()[0].raw();  // returns { color: 'blue' }

const list = document.list('numbers', { withTrace: true });
list[0].trace.raw();  // returns '13'
-- js

#### return value

description: A native representation of the value element.

### toString

syntax: toString() → string

-- description
Retrieve an abstract debug representation of of this `EnoValue`.
The representation differs depending on whether there is a name (e.g. for a field value)
or not (applies only to list item values).
-- description

-- eno
color: blue
numbers:
- 13
- 42
-- eno

-- js
const document = eno.parse(input);

document.sequential()[0].toString();  // returns '[object EnoValue name="color" value="blue"]'

const list = document.list('numbers', { withTrace: true });
list[0].trace.toString();  // returns '[object EnoValue value="13"]'
-- js

#### return value

description: An abstract debug representation of this `EnoValue`.

### value

syntax:
| value() → value or null
| value(loader) → value or null

-- description
Retrieve the value of an `EnoValue`, optionally passing it through a loader function.
-- description

-- eno
flag color: beige
towel color:
|
-- eno

-- js
const document = eno.parse(input);

const flagColor = document.sequential()[0];
const towelColor = document.sequential()[1];

flagColor.value();  // returns 'beige'
towelColor.value();  // returns null

flagColor.value(({ value }) => value.replace('eig', 'lu'));   // returns 'blue'
-- js

#### parameters

loader:
| A function returning the transformed/validated value or throwing an error.  
| The function is passed `name` and `value` inside a single object parameter.

#### return value

description: The (optionally transformed/validated) value of this `EnoValue`.

## EnoList

-- class description
Lists such as the one below are represented as an `EnoList`:

```eno
things:
- toys
- plants
```

Like `EnoValue`, you will seldom interact with this class, and instead use the `list`
accessor on the document or its sections to directly obtain the values of a list.
-- class description

### items

syntax:
| items() → array
| items(loader) → array

-- description
Retrieve the items of the list, optionally passing them through a loader function.
-- description

-- eno
colors:
- pink
- peach
-- eno

-- js
const document = eno.parse(input);
const list = document.sequential()[0]

list.items();  // returns ['pink', 'peach']

list.items(({ value }) => `${value}!!`);  // returns ['pink!!', 'peach!!']
-- js

#### return value

description: The (optionally transformed/validated) items of this list as an array.

### raw

syntax: raw() → object

-- description
Retrieve a native representation of the list.
-- description

-- eno
colors:
- pink
- peach
-- eno

-- js
const document = eno.parse(input);

document.sequential()[0].raw();  // returns { colors: ['pink', 'peach'] }
-- js

#### return value

description: A native javascript representation of the list.

### toString

syntax: toString() → string

-- description
Retrieve an abstract debug representation of the list.
-- description

-- eno
numbers:
- 13
- 42
-- eno

-- js
const document = eno.parse(input);

document.list('numbers').toString();  // returns '[object EnoList name="numbers" items=2]'
-- js

#### return value

description: An abstract debug representation of the list.

## EnoDictionary

-- class description
Dictionaries are represented as an `EnoDictionary`:

```eno
rated things:
toys = 5 stars
plants = 3 stars
```

You will mostly obtain an instance of this through the `dictionary` accessor on a document/section.
-- class description

### assertAllTouched

syntax:
| assertAllTouched()
| assertAllTouched(options)
| assertAllTouched(message or messageFunction)
| assertAllTouched(message or messageFunction, options)

-- description
Assert that all entries of this dictionary that were present in the parsed eno document
were also queried (and therefore *touched*) by the application. This, combined with eno's
query methods, serves to ensure a two-way guarantee for both users and developers:
No data that the application requires can be left out, and no data that the application
does not process can be supplied.
-- description

-- eno
Important data:
A = I need to be processed!
B = Me too!
-- eno

-- js
const document = eno.parse(input);

const dataA = document.dictionary('Important data').entry('A');

// ... processing happens only for dataA

document.assertAllTouched(); // throws an error
-- js

#### parameters

-- message or messageFunction
Optional, usually the default message (*An excess element named [NAME] was
found, is it possibly a typo?*) will do fine. If you want to override it,
provide either a static message as a string, or alternatively a function
returning a string. (The function is passed `name` and `value` inside a single
object parameter.)
-- message or messageFunction

-- options
An optional object.
 
`only` - An array of strings, e.g. `['name', 'email']`, which tells enojs to only check these entries for whether they've been touched.  
`except` - An array of strings, e.g. `['phone number']`, which tells enojs to exclude these entries from checking whether they've been touched.  
-- options

### entry

syntax:
| entry(name) → value or null
| entry(name, loader) → value or null
| entry(name, options) → object/value or null
| entry(name, loader, options) → object/value or null

-- description
Retrieve an entry's value from the dictionary, optionally supplying a loader to
validate and/or transform the value, and/or an options object.
-- description

-- eno
Q&A:
Meaning = 42
Green = Yes
Purpose =
-- eno

-- js
const document = eno.parse(input);
const qa = document.dictionary('Q&A');

qa.entry('Meaning');   // returns '42'
qa.entry('Purpose');   // returns null

qa.entry('Purpose', { required: true });   // throws an error
qa.entry('Purpose', { enforcePresence: true });   // returns null
qa.entry('Beige', { enforcePresence: true });   // throws an error

qa.entry('Green', ({ value }) => value.toUpperCase());   // returns 'YES'

qa.entry('Meaning', ({ value }) => {   // throws an error
  if(value === '42') {
    throw "That one's getting old!";
  }
  return value;
});

qa.entry('Meaning', { withTrace: true });   // returns { trace: [object EnoValue name="Meaning" value="42"], value: '42' }
-- js

#### parameters

name: The name of the entry as a string.

loader:
| A function returning the transformed/validated value or throwing an error.  
| The function is passed `name` and `value` inside a single object parameter.

-- options
An optional object of options:  
`enforcePresence`: Whether the entry must be present in the document (defaults to `false`)  
`required`: Whether there must be a value for this entry (defaults to `false`)  
`withTrace`: Whether to return an object with both the element and the value (defaults to `false`)
-- options

#### return value

description: The entry's value, or `null` if empty.

### enforcePresence

syntax:
| enforcePresence()
| enforcePresence(enforce)

-- description
Set the default for all following queries on this dictionary of whether the
presence of elements in the eno input text should be enforced (by default it is
not). This can be used to prevent "template decay" - with presence enforcement
enabled entries may be empty, but they (at least their declaration) must be
there in the eno document and consequently they can not disappear from a
template at any point without triggering an error.
-- description

-- eno
conversions:
0001 = 1
0010 = 2
-- eno

-- js
const document = eno.parse(input);

const conversions = document.dictionary('conversions');

conversions.enforcePresence(true);

conversions.entry('0011');  // throws an error
conversions.entry('0011', { enforcePresence: false });  // returns null
-- js

#### parameters

enforce: An optional boolean indicating whether to enforce or not. (otherwise `true` is assumed)

### raw

syntax: raw() → object

-- description
Retrieve a native representation of the dictionary.
-- description

-- eno
weights:
apple = 100g
pineapple = 800g
-- eno

-- js
const document = eno.parse(input);

document.dictionary('weights').raw();  // returns { weights: { apple: '100g', pineapple: '800g' } }
-- js

#### return value

description: A native object representation of the dictionary.

### toString

syntax: toString() → string

-- description
Retrieve an abstract debug representation of the dictionary.
-- description

-- eno
numbers:
13 = thirteen
23 = twentythree
-- eno

-- js
const document = eno.parse(input);

document.dictionary('numbers').toString();  // returns '[object EnoDictionary name="numbers" entries=2]'
-- js

#### return value

description: An abstract debug representation of the dictionary.

## EnoEmpty

-- class description
This represents empty elements such as `color:`, where it is not clear if it is an empty field, list, or dictionary.
-- class description

### getError

syntax:
| getError() → EnoValidationError
| getError(message or messageFunction) → EnoValidationError

-- description
Generate an error in the context of the element. The error includes a generic
message by default, or a custom one if you supply it (which is the recommended
practice). You can also pass a message function which (like the loader functions
too) gets the name and value as arguments and returns a message string. This
serves to create highly informative error messages that pin-point to the exact
origin of the error, even when the initial reading of data is already past, e.g.
when the error condition is only apparent later, when more processing has
occurred or other data is available.
-- description

-- eno
color:
-- eno

-- js
const document = eno.parse(input);
const { trace, value } = document.field('color', { withTrace: true });

// ...

if(value === null) {
  throw trace.getError('Postprocessing determined that this value needs to be provided.');
}
-- js

#### parameters

message or messageFunction:
| Highly recommended to provide one (but it's optional).
|
| Either directly pass a string, or alternatively a function returning a string.  
| (The function is passed `name` and `value` inside a single object parameter.)

#### return value

description:
| An `EnoValidationError` in the context of the element's value
| (and with an optional custom message).

### raw

syntax: raw() → object

-- description
Retrieve a native representation of the empty element.
-- description

-- eno
color:
-- eno

-- js
const document = eno.parse(input);

document.sequential()[0].raw();  // returns { color: null }
-- js

#### return value

description: A native representation of the empty element.

### toString

syntax: toString() → string

-- description
Retrieve an abstract debug representation of the empty element.
-- description

-- eno
color:
-- eno

-- js
const document = eno.parse(input);
const elements = document.sequential();

elements[0].toString();  // returns '[object EnoEmpty name="color"]'
-- js

#### return value

description: An abstract debug representation of the empty element.

### value

syntax:
| value() → null

-- description
Retrieve the value (always returns `null`).
-- description

-- eno
note:
-- eno

-- js
const document = eno.parse(input);

const note = document.sequential()[0];

note.value();  // returns null
-- js

#### return value

description: Always `null`.

## EnoError

-- class description
The single generic error interface for all (user) errors that eno generates.
Note that this is never thrown by itself, but only in one of it's subclassed
variants (`EnoParseError` and `EnoValidationError`). However, you can still
utilize this generic class in cases where you want to catch both parser and
validation errors indiscriminately, like so:

```js
try {
  // ...
} catch(err) {
  if(err instanceof EnoError) { // catches both EnoParseError and EnoValidationError
    // ...
  }
}
```
-- class description

### cursor

syntax: cursor → [line, column]

-- description
Returns a cursor position as an array of the form [line, column], indicating
where a cursor should be placed if an application wants to offer the user a way
to move the cursor straight to the error location.
-- description

-- js
try {
  // ...
} catch(err) {
  if(err instanceof EnoError) {
    err.cursor;  // returns [3, 14]
  }
}
-- js

#### return value

description: An array, where [0] is the line number, and [1] is the column number.

### selection

syntax: selection → [[line, column], [line, column]]

-- description
Returns a selection as an array of the form [[line, column], [line, column]],
indicating a text range to select if an application wants to offer the user a
way to get a selection for the error in the input.
-- description

-- js
try {
  // ...
} catch(err) {
  if(err instanceof EnoError) {
    err.selection;  // returns [[3, 14], [3, 23]]
  }
}
-- js

#### return value

description:
| An array, where [0] is the begin of the selection and [1] is the end,
| and both begin and end are each again an array, where [0] is the
| line number, and [1] is the column number.

### message

syntax: message → string

-- description
Contains both the error text as well as the snippet. This is also what you
get in the console when you don't catch the error.
-- description

-- js
try {
  // ...
} catch(err) {
  if(err instanceof EnoError) {
    err.message;  // returns "In line 4 'a' is copied into itself.\n\n   Line | Content\n ..."
  }
}
-- js

#### return value

description: Both the error text as well as the snippet.

### snippet

syntax: snippet → string

-- description
Returns a formatted excerpt of those passage(s) from the input where the error occurred.
-- description

-- js
try {
  // ...
} catch(err) {
  if(err instanceof EnoError) {
    err.snippet;
    
    // returns something like ...
    //
    //   Line | Content
    //      1 | 
    // *    2 |     # a
    // *    3 |     ## b
    // >    4 |     ### c < a
    //      5 |
  }
}
-- js

#### return value

description: A formatted excerpt of those passage(s) from the input where the error occurred.

### text

syntax: text → string

-- description
Returns a one-liner that describes the error in human language.
-- description

-- js
try {
  // ...
} catch(err) {
  if(err instanceof EnoError) {
    err.message;  // returns 'In line 4 'a' is copied into itself.'
  }
}
-- js

#### return value

description: A single sentence that describes the error in human language.

## EnoParseError

-- class description
When this is thrown, it indicates an error regarding syntax or grammatical semantics of the document.
Functionally this behaves exactly like `EnoError`, therefore the interface methods are not repeated here and can
be looked up on the `EnoError` documentation.
-- class description

## EnoValidationError

-- class description
When this is thrown, it indicates an error regarding application-specific requirements for the document.
Functionally this behaves exactly like `EnoError`, therefore the interface methods are not repeated here and can
be looked up on the `EnoError` documentation.
-- class description
