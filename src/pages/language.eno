title: Write your content with eno

# content

-- markdown
# Language

## User guide

For the beginner-friendly user guide in video or text form, visit
[eno-lang.org/introduction](https://eno-lang.org/introduction/) for the
introduction and then optionally
[eno-lang.org/advanced](https://eno-lang.org/advanced/) to learn about the
advanced features.

## Developer guide / Cheatsheet

If you're a developer or otherwise familiar with structured text formats like YAML or TOML
you will likely gather most things you need to know on this page (note that all topics are
handled with more detail in the user guide though, if you miss something on this page),
here's the quick rundown:

eno is unaware of indentation and whitespace in general - before, after and
between all language tokens (names, operators and values) you can have as much
or little space and empty lines as you wish.

eno is line-based, there is only a single necessary exception, which is the multiline field ("block").

Without further ado, here is the quick tour:

```eno
> Text of Comment

Field: Value

-- Block
Value of ...
... Block
-- Block

--- Block
Value of ...
-- Block
... block
--- Block

List:
- Value
- Value

Dictionary:
Entry A = Value
Entry B = Value

Field: Line ...
\ ... continuation
\ ... (separated with space)

Field: Line ...
| Newline continuation
| (separated with linebreak)

Name of copy < Name of source element

# Section
## Subsection
### Subsubsection

# Name of section copy < Name of source section
# Name of deep-merged section copy << Name of source section

`Escaped field name`: Value

`Escaped list name`:
- Value
- Value

`Escaped dictionary name`:
`Escaped entry A` = Value
`Escaped entry B` = Value

`Escaped name of copy` < Name of source element

# `Escaped name of section copy` < Name of source section
```

## Language stability and development plan

The eno language as documented, shown and used throughout this page, all repositories, and all case studies,
is a fully designed and developed release candidate (1.0.0-RC if you will), whose aptness for a
broad variety of usecases has already been tested in multiple, diverse case studies.

For the coming months up until the end of 2018 this stage (frozen RC) will be
kept, with the goal of gathering more and broader data and insights on any
possibly overlooked language design flaws, inconsistencies or absolutely
required changes.

Based on this data a final specification will be compiled and ratified around Q2
2019, which should only introduce breaking changes if there are very fundamental
reasons found for such changes.

As soon as this second and at the same time last specification goes into effect
and is fully supported by all library implementations it will consequently be
frozen and locked, with no further changes planned nor allowed from that point
on, or in other words, eno "1.0.0 Final" will be the next and last iteration
of the language.

## Formal language specification document

A formal writedown of the language specification in ABNF notation is in the making, as there a lot of areas that need
attention it might still take a while until it will go online though. Stay tuned!
-- markdown
